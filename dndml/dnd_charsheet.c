#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdarg.h>
#include <limits.h>
#include <string.h>
#include "dnd_lexer.h"
#include "dnd_charsheet.h"
#include "../dice.h"

#ifdef DEBUG_LVL
  #if DEBUG_LVL == 0
    #define DEBUG1(x) ;
    #define DEBUG2(x) ;
  #elif DEBUG_LVL == 1
    #define DEBUG1(x) x;
    #define DEBUG2(x) ;
  #elif DEBUG_LVL == 2
    #define DEBUG1(x) x;
    #define DEBUG2(x) x;
  #endif
#else
  #warning DEBUG_LVL undefined; defaulting to 0
  #define DEBUG1(x) ;
  #define DEBUG2(x) ;
#endif

static char global_buf[4096];

static char *dstrcat(char *dest, const char *str_to_append) {
  DEBUG1(
    fprintf(stderr, "~~ Calling dstrcat(");
    if (dest) {
      fprintf(stderr, "\"%s\", \"%s\").\n", dest, str_to_append);
    } else {
      fprintf(stderr, "%p, \"%s\").\n", dest, str_to_append);
    }
    fprintf(stderr, "~~ ============== ~~\n");
  );
  size_t bufsize;
  if (dest != NULL)
    bufsize = 1 + snprintf(NULL, 0, "%s", str_to_append) + strlen(dest);
  else
    bufsize = 1 + snprintf(NULL, 0, "%s", str_to_append);
  DEBUG2(
    fprintf(
      stderr, "~~   Allocating %lu chars to dest.\n", bufsize
    );
    fprintf(
      stderr,
      "~~   strlen(dest): %lu\n",
      dest == NULL ? 0 : strlen(dest)
    );
  );
  _Bool should_not_strlen_dest = dest == NULL;
  dest = realloc(dest, bufsize);
  if (should_not_strlen_dest)
    sprintf(dest, str_to_append);
  else
    sprintf(dest + strlen(dest), str_to_append);

  DEBUG2(fprintf(stderr, "~~   Result: \"%s\"\n", dest));
  return dest;
}

void free_charsheet(charsheet_t *csp) {
  for (int i = 0; i < csp->section_count; i++) {
    for (int j = 0; j < csp->sections[i].field_count; j++) {
      if (csp->sections[i].fields[j].type == itemlist_val) {
        for (
          int k = 0;
          k < csp->sections[i].fields[j].itemlist_val.item_count;
          k++
        ) {
          free(csp->sections[i].fields[j].itemlist_val.items[k].val);
        }
        free(csp->sections[i].fields[j].itemlist_val.items);
      } else if (csp->sections[i].fields[j].type == string_val) {
        free(csp->sections[i].fields[j].string_val);
      }
      free(csp->sections[i].fields[j].identifier);
    }
    free(csp->sections[i].fields);
    free(csp->sections[i].identifier);
  }
  free(csp->sections);
  free(csp);
}

char *charsheet_to_str(charsheet_t *csp) {
  char *result = NULL;
  result = dstrcat(
    result,
    "~~ Character sheet autogenerated by tryptobot.\n"
    "~~ Timestamp: %d\n\n",
    time(NULL) // TODO: this is vulnerable to the 2038 problem
  );

  for (int i = 0; i < csp->section_count; i++) {
    DEBUG2(
      fprintf(
        stderr,
        "~~   Attempting to cat \"%s\".\n",
        csp->sections[i].identifier
      );
    );
    result = dstrcat(
      result,
      "@section %s:\n",
      csp->sections[i].identifier
    );
    for (int j = 0; j < csp->sections[i].field_count; j++) {
      DEBUG2(
        fprintf(
          stderr,
          "~~   Attempting to cat \"%s\".\n",
          csp->sections[i].fields[j].identifier
        );
      );
      snprintf() // TODO snprintf to global_buf
      result = dstrcat(
        result,
        "  @field %s: ",
        csp->sections[i].fields[j].identifier
      );
      switch (csp->sections[i].fields[j].type) {
        case stat_val:
          result = dstrcat(result, "%%stat[ability:");
          if (csp->sections[i].fields[j].stat_val.ability == INT_MIN) {
            result = dstrcat(result, "NULL;mod:");
          } else {
            result = dstrcat(
              result, "%d;mod:",
              csp->sections[i].fields[j].stat_val.ability
            );
          }
          if (csp->sections[i].fields[j].stat_val.mod == INT_MIN) {
            result = dstrcat(result, "NULL];\n");
          } else {
            result = dstrcat(
              result, "%d];\n",
              csp->sections[i].fields[j].stat_val.mod
            );
          }
        break;
        case string_val:
          if (csp->sections[i].fields[j].string_val == NULL) {
            result = dstrcat(result, "%%string[NULL];\n");
          } else {
            result = dstrcat(
              result,
              "%%string[\"%s\"];\n",
              csp->sections[i].fields[j].string_val
            );
          }
        break;
        case int_val:
          if (csp->sections[i].fields[j].int_val == INT_MIN) {
            result = dstrcat(result, "%%int[NULL];\n");
          } else {
            result = dstrcat(
              result,
              "%%int[%d];\n",
              csp->sections[i].fields[j].int_val
            );
          }
        break;
        case dice_val:
          result = dstrcat(result, "%%dice[");
          if (csp->sections[i].fields[j].dice_val.value == INT_MIN) {
            result = dstrcat(result, "%%dice[NULL];\n");
          } else {
            result = dstrcat(
              result,
              "%%dice[%dd%d+%d];\n",
              csp->sections[i].fields[j].dice_val.dice_ct,
              csp->sections[i].fields[j].dice_val.faces,
              csp->sections[i].fields[j].dice_val.modifier
            );
          }
        break;
        case deathsave_val:
          result = dstrcat(result, "%%deathsaves[succ:");
          if (csp->sections[i].fields[j].deathsave_val.succ == INT_MIN) {
            result = dstrcat(result, "NULL;fail:");
          } else {
            result = dstrcat(
              result, "%d;fail:",
              csp->sections[i].fields[j].deathsave_val.succ
            );
          }
          if (csp->sections[i].fields[j].deathsave_val.fail == INT_MIN) {
            result = dstrcat(result, "NULL];\n");
          } else {
            result = dstrcat(
              result, "%d];\n",
              csp->sections[i].fields[j].deathsave_val.fail
            );
          }
        break;
        case itemlist_val:
          result = dstrcat(result, "%%itemlist[\n");
          for (
            int k = 0;
            k < csp->sections[i].fields[j].itemlist_val.item_count;
            k++
          ) {
            result = dstrcat(result, "    %%item[val:");
            if (csp->sections[i].fields[j].itemlist_val.items[k].val == NULL) {
              result = dstrcat(result, "NULL;qty:");
            } else {
              result = dstrcat(
                result,
                "\"%s\";qty:",
                csp->sections[i].fields[j].itemlist_val.items[k].val
              );
            }
            if (csp->sections[i].fields[j].itemlist_val.items[k].qty == INT_MIN) {
              result = dstrcat(result, "NULL;weight:");
            } else {
              result = dstrcat(
                result,
                "%d;weight:",
                csp->sections[i].fields[j].itemlist_val.items[k].qty
              );
            }
            if (csp->sections[i].fields[j].itemlist_val.items[k].qty == INT_MIN) {
              result = dstrcat(result, "NULL];\n");
            } else {
              result = dstrcat(
                result,
                "%d];\n",
                csp->sections[i].fields[j].itemlist_val.items[k].weight
              );
            }
          }
          result = dstrcat(result, "  ];\n");
        break;
        case item_val:
          result = dstrcat(result, "    %%item[val:");
          if (csp->sections[i].fields[j].item_val.val == NULL) {
            result = dstrcat(result, "NULL;qty:");
          } else {
            result = dstrcat(
              result,
              "\"%s\";qty:",
              csp->sections[i].fields[j].item_val.val
            );
          }
          if (csp->sections[i].fields[j].item_val.qty == INT_MIN) {
            result = dstrcat(result, "NULL;weight:");
          } else {
            result = dstrcat(
              result,
              "%d;weight:",
              csp->sections[i].fields[j].item_val.qty
            );
          }
          if (csp->sections[i].fields[j].item_val.qty == INT_MIN) {
            result = dstrcat(result, "NULL];\n");
          } else {
            result = dstrcat(
              result,
              "%d];\n",
              csp->sections[i].fields[j].item_val.weight
            );
          }
        break;
        default:
          free(result);
          return NULL;
        break;
      }
    }
    result = dstrcat(result, "@end-section\n\n");
  }

  return result;
}
